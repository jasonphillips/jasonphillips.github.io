{"componentChunkName":"component---src-templates-project-tsx","path":"/projects/admissionsTracking","result":{"data":{"markdownRemark":{"id":"5cbb52a0-c86c-5590-87d6-c5b7bd226fa6","html":"<p>In this project, I built a data &#x26; reporting pipeline for admissions data for the university administration, with the ultimately realized goal of becoming a sole, centralized set of numbers upon which all parties (admissions, housing, student life, etc) can agree. At the outset, data for applicants was spread across countless Banner (Oracle) tables that were mutable without history, rapidly changing daily, and filled with messy designations or often conflicting codes.</p>\n<p>After working through the existing wall-sized SQL queries used by invested parties and then mapping out all the tables and rules, I constructed a graph-based schema using <code>join-monster</code> in <a href=\"/technologies/graphql\">GraphQL</a>, which meant realizing a clear, well-documented set of paths through the data from applicant, to extant applications, to decisions and actions, demographics records, etc. </p>\n<p>From there, I wrote a minimal complete graph query representing everything we need to know about an applicant / application, so that a clean, nested object could be obtained from the schema. But that only obtains the still-conradictory and indeterminate data that is still in want of various top-level decisions (e.g., does this count as an application deposit or a deposit waiver?). Next, I wrote a series of rules (in Typescript) that run against one of these objects, with each rule deriving some piece of metadata from examining the object, and/or based on a reading of metadata from prior rules. By running each applicant object through this metadata layer, I obtained well-justified information ready for reporting.</p>\n<p>Each night, I run a task that fires up this GraphQL schema and its rules code within a Docker container, pulling all applicants as of that moment, and writing into a Mongo collection. This Mongo collection is then wired into a reporting dashboard with strong aggregation pipeline code that enables slicing charts by any combination of demographic or application attributes, and rolls up the timestamped data of prior terms up to the same data for comparison. This needed to be fast, so significant effort was devoted to writing smart and efficient pipelines, since all of the main computation occurs there. </p>\n<p>The resulting views and dynamic dashboard (<a href=\"/technologies/react\">React</a> and Apollo) are used by many key players at the instutition daily, and the data also powers regular reporting requirements. The scope and capabilities continue to expand due to its popularity. </p>","frontmatter":{"title":"Admissions Tracking & Visualizations","tags":["graphql","microservices","mongodb","sql","nodejs","javascript","react","d3","data visualization"],"parent":null}},"tags":{"nodes":[{"id":"7a9da462-1ce0-5f4a-b6d0-3a9bf147171d","fields":{"slug":"/technologies/graphql","tag":"graphql"},"frontmatter":{"title":"GraphQL"}},{"id":"0c42cc39-d1e0-5c3a-b643-7b0473ecf678","fields":{"slug":"/technologies/microservices","tag":"microservices"},"frontmatter":{"title":"Microservices"}},{"id":"715705b3-cc96-5459-b34f-93ae8ed8939c","fields":{"slug":"/technologies/mongodb","tag":"mongodb"},"frontmatter":{"title":"MongoDB"}},{"id":"a09e8c4d-4270-59cc-86dd-694aa938075b","fields":{"slug":"/technologies/nodejs","tag":"nodejs"},"frontmatter":{"title":"Node.js"}},{"id":"97c03e57-9ce8-5f83-ab7e-6d87587a8f41","fields":{"slug":"/technologies/react","tag":"react"},"frontmatter":{"title":"React"}},{"id":"f5c482a5-c9ff-5af7-b18b-26b543db0664","fields":{"slug":"/technologies/sql","tag":"sql"},"frontmatter":{"title":"SQL and Relational Databases"}}]}},"pageContext":{"tags":["graphql","microservices","mongodb","sql","nodejs","javascript","react","d3","data visualization"]}}}