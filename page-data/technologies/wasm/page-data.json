{"componentChunkName":"component---src-templates-technology-tsx","path":"/technologies/wasm","result":{"data":{"markdownRemark":{"id":"0aef1bb4-168f-52d6-9b45-57b0d7a094ed","html":"<p>My work with WebAssembly has been in <a href=\"/technologies/cpp\">C++</a> using Emscripten and <a href=\"/technologies/rust\">rust</a> using <code>wasm-pack</code>. In both cases, I worked with complex dependencies, serializing and deserializing structures to and from the browser, and loading into memory external model files as needed. I also have developed all of my <code>wasm</code> libraries to run equivalently in the browser and within NodeJS on the server, which poses particular challenges with ingesting model files. </p>\n<p>Having deployed WebAssembly into production in an application that fires up and coordinates several <code>wasm</code> bundles from within a background WebWorker, I have a full grasp of the way this new terrain of web development opens up possibilites in cases where highly efficient code is needed and Javascript won’t suffice. </p>\n<p>In <a href=\"/projects/browserNLP\">one case</a>, I worked to efficiently build an entire NLP pipeline in the resource-constrained context of the browser—going from tokenization, though tagging, stemming, lemmatization, dependency parsing, and then applying top-level rules or vector-space comparisons, all within a chain of WASM-compiled tools communicating smoothly and running in a background WebWorker.</p>","frontmatter":{"title":"WebAssembly","tags":["rust"],"competence":"advanced","parent":null}},"tags":{"nodes":[{"id":"d4ca853c-81ba-5b63-a722-45cea24afa97","fields":{"slug":"/technologies/rust","tag":"rust"},"frontmatter":{"title":"Rust"}}]}},"pageContext":{"tags":["rust"]}}}