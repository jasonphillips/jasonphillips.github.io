{"componentChunkName":"component---src-templates-technology-tsx","path":"/technologies/rabbitmq","result":{"data":{"markdownRemark":{"id":"8a426e8c-3ffb-59d4-b187-65bc14e9ddb0","html":"<p>My work with RabbitMQ has been restricted to creating work queues, either for a side-effects channel or for centralized management of tasks in a production cluster. RabbitMQ managed channels for pushing various tasks, which were picked up by workers as available, then in some cases a kind of subscription on the calling end (in one application, these were eventually surfaced to user under GraphQL subscriptions) would kick off upon a task completion being published. </p>\n<p>A preview of my strategy for setting up workers is below, in my original gist where I came up with a way of wrapping rabbit with an interface inspired by <code>express</code> routing, to make setting up a worker dramatically easier. I iterated on this strategy quite a bit in a particular application, but the foundation remained. </p>\n<p><a href=\"https://gist.github.com/jasonphillips/81f2d73ba9d76b1de4cdcdf3528bbe04\">https://gist.github.com/jasonphillips/81f2d73ba9d76b1de4cdcdf3528bbe04</a> (see <em>usage.js</em>)</p>","frontmatter":{"title":"RabbitMQ","tags":["microservices"],"competence":null,"parent":null}},"tags":{"nodes":[{"id":"0c42cc39-d1e0-5c3a-b643-7b0473ecf678","fields":{"slug":"/technologies/microservices","tag":"microservices"},"frontmatter":{"title":"Microservices"}}]}},"pageContext":{"tags":["microservices"]}}}